name: üöÄ Production Deployment Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (optional, defaults to latest)'
        required: false
        default: 'latest'
      skip_tests:
        description: 'Skip test phase'
        type: boolean
        required: false
        default: false

env:
  REGISTRY: ghcr.io
  REGISTRY_PREFIX: ghcr.io/philksr/planetplant
  NODE_VERSION: '20'

jobs:
  # =============================================================================
  # BUILD MULTI-ARCHITECTURE IMAGES
  # =============================================================================
  build:
    name: üèóÔ∏è Build & Push Images
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      packages: write
      
    outputs:
      version: ${{ steps.version.outputs.version }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
      nginx-digest: ${{ steps.build-nginx.outputs.digest }}
      
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # For semantic versioning
        
    - name: üè∑Ô∏è Generate Version
      id: version
      run: |
        if [ "${{ github.event.inputs.version }}" != "" ]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          # Use git describe for semantic versioning
          if git describe --tags --exact-match HEAD 2>/dev/null; then
            VERSION=$(git describe --tags --exact-match HEAD)
          else
            VERSION="v$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)"
          fi
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "üè∑Ô∏è Version: ${VERSION}"
        
    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64,linux/arm64
        
    - name: üîê Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üèóÔ∏è Build & Push Backend Image
      id: build-backend
      uses: docker/build-push-action@v5
      with:
        context: ./raspberry-pi
        file: ./raspberry-pi/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ env.REGISTRY_PREFIX }}/backend:latest
          ${{ env.REGISTRY_PREFIX }}/backend:${{ steps.version.outputs.version }}
        labels: |
          org.opencontainers.image.title=PlanetPlant Backend
          org.opencontainers.image.description=Smart IoT Plant Watering System - Backend API
          org.opencontainers.image.version=${{ steps.version.outputs.version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
        cache-from: type=gha,scope=backend
        cache-to: type=gha,mode=max,scope=backend
        
    - name: üåê Build & Push Frontend Image
      id: build-frontend
      uses: docker/build-push-action@v5
      with:
        context: ./webapp
        file: ./webapp/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ env.REGISTRY_PREFIX }}/frontend:latest
          ${{ env.REGISTRY_PREFIX }}/frontend:${{ steps.version.outputs.version }}
        labels: |
          org.opencontainers.image.title=PlanetPlant Frontend
          org.opencontainers.image.description=Smart IoT Plant Watering System - React PWA
          org.opencontainers.image.version=${{ steps.version.outputs.version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
        cache-from: type=gha,scope=frontend
        cache-to: type=gha,mode=max,scope=frontend
        
    - name: üîÄ Build & Push Nginx Proxy Image
      id: build-nginx
      uses: docker/build-push-action@v5
      with:
        context: ./nginx
        file: ./nginx/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ env.REGISTRY_PREFIX }}/nginx-proxy:latest
          ${{ env.REGISTRY_PREFIX }}/nginx-proxy:${{ steps.version.outputs.version }}
        labels: |
          org.opencontainers.image.title=PlanetPlant Nginx Proxy
          org.opencontainers.image.description=Smart IoT Plant Watering System - Reverse Proxy
          org.opencontainers.image.version=${{ steps.version.outputs.version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
        cache-from: type=gha,scope=nginx
        cache-to: type=gha,mode=max,scope=nginx
        
    - name: üìã Build Summary
      run: |
        echo "üéâ All images built successfully!"
        echo "üì¶ Backend: ${{ env.REGISTRY_PREFIX }}/backend:${{ steps.version.outputs.version }}"
        echo "üåê Frontend: ${{ env.REGISTRY_PREFIX }}/frontend:${{ steps.version.outputs.version }}"
        echo "üîÄ Nginx: ${{ env.REGISTRY_PREFIX }}/nginx-proxy:${{ steps.version.outputs.version }}"

  # =============================================================================
  # INTEGRATION TESTING
  # =============================================================================
  test:
    name: üß™ Integration Tests
    runs-on: ubuntu-latest
    needs: [build]
    if: ${{ !inputs.skip_tests }}
    
    services:
      redis:
        image: redis:7.2.5-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
          
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: üìã Create Test Environment
      run: |
        cp raspberry-pi/.env.example .env
        echo "REGISTRY_PREFIX=${{ env.REGISTRY_PREFIX }}" >> .env
        echo "IMAGE_TAG=${{ needs.build.outputs.version }}" >> .env
        
    - name: üîê Login to Registry for Image Pull
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üöÄ Start Test Environment
      run: |
        # Remove override to use registry images
        rm -f docker-compose.override.yml
        docker compose up -d --no-build
        
    - name: ‚è≥ Wait for Services to Start
      run: |
        echo "‚è≥ Waiting for services to initialize..."
        sleep 60
        
    - name: üîç Service Status Check
      run: |
        echo "üê≥ Container Status:"
        docker compose ps
        echo ""
        echo "ü©∫ Service Health:"
        docker compose logs --tail=20
        
    - name: üß™ Health Checks
      run: |
        echo "ü©∫ Testing service health endpoints..."
        
        # Wait for InfluxDB
        timeout 120 bash -c 'until curl -f http://localhost:8086/ping; do sleep 2; done'
        echo "‚úÖ InfluxDB is healthy"
        
        # Wait for Backend API
        timeout 120 bash -c 'until curl -f http://localhost:3001/api/system/status; do sleep 2; done'
        echo "‚úÖ Backend API is healthy"
        
        # Wait for Frontend
        timeout 60 bash -c 'until curl -f http://localhost/health; do sleep 2; done'
        echo "‚úÖ Frontend is healthy"
        
    - name: üß™ API Integration Tests
      run: |
        echo "üß™ Running API tests..."
        
        # Test system status
        RESPONSE=$(curl -s http://localhost/api/system/status)
        if echo "$RESPONSE" | jq -e '.success == true' > /dev/null; then
          echo "‚úÖ System status API working"
        else
          echo "‚ùå System status API failed"
          exit 1
        fi
        
        # Test plants API
        PLANTS_RESPONSE=$(curl -s http://localhost/api/plants)
        if echo "$PLANTS_RESPONSE" | jq -e '.success == true' > /dev/null; then
          echo "‚úÖ Plants API working"
        else
          echo "‚ùå Plants API failed"
          exit 1
        fi
        
        # Test frontend serving
        if curl -f -s http://localhost/ > /dev/null; then
          echo "‚úÖ Frontend serving correctly"
        else
          echo "‚ùå Frontend not accessible"
          exit 1
        fi
        
    - name: üìä Performance Tests
      run: |
        echo "üìä Running performance tests..."
        
        # Test API response times
        for i in {1..5}; do
          START=$(date +%s%N)
          curl -s http://localhost/api/system/status > /dev/null
          END=$(date +%s%N)
          DURATION=$(( (END - START) / 1000000 ))
          echo "API response $i: ${DURATION}ms"
          
          if [ $DURATION -gt 2000 ]; then
            echo "‚ùå API response too slow: ${DURATION}ms"
            exit 1
          fi
        done
        echo "‚úÖ API performance acceptable"
        
    - name: üõë Cleanup Test Environment
      if: always()
      run: |
        docker compose logs --tail=50 || true
        docker compose down -v || true

  # =============================================================================
  # PRODUCTION DEPLOYMENT
  # =============================================================================
  deploy:
    name: üçì Deploy to Raspberry Pi
    runs-on: ubuntu-latest
    needs: [build, test]
    if: ${{ always() && needs.build.result == 'success' && (needs.test.result == 'success' || inputs.skip_tests) }}
    environment: production
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    - name: üîê Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PI_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H "${{ secrets.PI_HOST }}" >> ~/.ssh/known_hosts
        
    - name: üì¶ Prepare Deployment Files
      run: |
        # Create deployment environment file
        cat > deploy.env << EOF
        REGISTRY_PREFIX=${{ env.REGISTRY_PREFIX }}
        IMAGE_TAG=${{ needs.build.outputs.version }}
        NODE_ENV=production
        EOF
        
    - name: üì§ Upload Deployment Files
      run: |
        # Create remote directory
        ssh pi@${{ secrets.PI_HOST }} "mkdir -p /opt/planetplant/deploy"
        
        # Upload compose file and environment
        scp docker-compose.yml pi@${{ secrets.PI_HOST }}:/opt/planetplant/deploy/
        scp deploy.env pi@${{ secrets.PI_HOST }}:/opt/planetplant/deploy/
        
        # Upload scripts
        scp -r scripts/ pi@${{ secrets.PI_HOST }}:/opt/planetplant/deploy/
        scp -r config/ pi@${{ secrets.PI_HOST }}:/opt/planetplant/deploy/
        
    - name: üîê Login to Registry on Pi
      run: |
        ssh pi@${{ secrets.PI_HOST }} "echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u ${{ github.actor }} --password-stdin"
        
    - name: üíæ Backup Current System
      run: |
        ssh pi@${{ secrets.PI_HOST }} "
          cd /opt/planetplant &&
          if [ -f docker-compose.yml ]; then
            echo 'üì¶ Creating pre-deployment backup...'
            tar -czf backup-pre-deploy-$(date +%Y%m%d-%H%M%S).tar.gz \
              docker-compose.yml .env data/ logs/ config/ || true
            echo '‚úÖ Backup created'
          fi
        "
        
    - name: üîÑ Rolling Update Deployment
      run: |
        ssh pi@${{ secrets.PI_HOST }} "
          cd /opt/planetplant/deploy &&
          echo 'üöÄ Starting rolling deployment...' &&
          
          # Load new environment
          set -a && source deploy.env && set +a &&
          
          # Pull new images
          echo 'üì• Pulling new images...' &&
          docker compose pull || exit 1 &&
          
          # Stop services in reverse dependency order
          echo 'üõë Stopping frontend services...' &&
          docker compose stop nginx-proxy frontend || true &&
          
          echo 'üîÑ Updating backend...' &&
          docker compose up -d backend --no-deps &&
          sleep 10 &&
          
          # Health check backend
          echo 'ü©∫ Checking backend health...' &&
          timeout 60 bash -c 'until curl -f http://localhost:3001/api/system/status; do sleep 2; done' &&
          
          echo 'üåê Updating frontend services...' &&
          docker compose up -d frontend nginx-proxy --no-deps &&
          sleep 5 &&
          
          echo '‚úÖ Rolling update completed'
        "
        
    - name: ü©∫ Post-Deployment Health Check
      run: |
        echo "ü©∫ Running post-deployment health checks..."
        
        ssh pi@${{ secrets.PI_HOST }} "
          # Wait for services to be fully ready
          sleep 15 &&
          
          # Check all services
          echo 'üîç Checking service status...' &&
          docker compose ps &&
          
          echo 'ü©∫ Testing health endpoints...' &&
          
          # Backend API
          timeout 30 bash -c 'until curl -f http://localhost:3001/api/system/status; do sleep 2; done' &&
          echo '‚úÖ Backend API responding' &&
          
          # Frontend
          timeout 30 bash -c 'until curl -f http://localhost/health; do sleep 2; done' &&
          echo '‚úÖ Frontend responding' &&
          
          # InfluxDB
          timeout 30 bash -c 'until curl -f http://localhost:8086/ping; do sleep 2; done' &&
          echo '‚úÖ InfluxDB responding' &&
          
          echo 'üéâ All health checks passed!'
        "
        
    - name: üìã Update Production Configuration
      run: |
        ssh pi@${{ secrets.PI_HOST }} "
          cd /opt/planetplant &&
          
          # Copy new configuration
          cp deploy/docker-compose.yml . &&
          cp deploy/deploy.env .env.deploy &&
          
          # Update any changed config files
          if [ -d deploy/config ]; then
            cp -r deploy/config/* config/ 2>/dev/null || true
          fi &&
          
          echo '‚úÖ Production configuration updated'
        "
        
    - name: üîÑ Restart Failed Services (if any)
      if: failure()
      run: |
        echo "‚ö†Ô∏è Deployment issues detected, attempting service restart..."
        ssh pi@${{ secrets.PI_HOST }} "
          cd /opt/planetplant &&
          docker compose restart &&
          sleep 20 &&
          docker compose ps
        "
        
    - name: üîô Rollback on Critical Failure
      if: failure()
      run: |
        echo "üîô Rolling back to previous version..."
        ssh pi@${{ secrets.PI_HOST }} "
          cd /opt/planetplant &&
          
          # Find most recent backup
          BACKUP=\$(ls -t backup-pre-deploy-*.tar.gz 2>/dev/null | head -1) &&
          
          if [ -n \"\$BACKUP\" ]; then
            echo 'üì¶ Restoring from backup: '\$BACKUP &&
            tar -xzf \$BACKUP &&
            docker compose up -d &&
            echo '‚úÖ Rollback completed'
          else
            echo '‚ùå No backup found, manual intervention required'
            exit 1
          fi
        "

  # =============================================================================
  # DEPLOYMENT NOTIFICATIONS
  # =============================================================================
  notify:
    name: üì¢ Deployment Notifications
    runs-on: ubuntu-latest
    needs: [build, test, deploy]
    if: always()
    
    steps:
    - name: üìä Determine Deployment Status
      id: status
      run: |
        BUILD_STATUS="${{ needs.build.result }}"
        TEST_STATUS="${{ needs.test.result }}"
        DEPLOY_STATUS="${{ needs.deploy.result }}"
        
        if [[ "$BUILD_STATUS" == "success" && ("$TEST_STATUS" == "success" || "$TEST_STATUS" == "skipped") && "$DEPLOY_STATUS" == "success" ]]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=üéâ Deployment successful" >> $GITHUB_OUTPUT
          echo "color=3066993" >> $GITHUB_OUTPUT  # Green
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=‚ùå Deployment failed" >> $GITHUB_OUTPUT  
          echo "color=15158332" >> $GITHUB_OUTPUT  # Red
        fi
        
    - name: üì± Discord Notification
      if: ${{ secrets.DISCORD_WEBHOOK }}
      run: |
        curl -H "Content-Type: application/json" -X POST \
          -d "{
            \"embeds\": [{
              \"title\": \"${{ steps.status.outputs.message }}\",
              \"description\": \"PlanetPlant Production Deployment\",
              \"color\": ${{ steps.status.outputs.color }},
              \"fields\": [
                {\"name\": \"Version\", \"value\": \"${{ needs.build.outputs.version }}\", \"inline\": true},
                {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                {\"name\": \"Commit\", \"value\": \"[\`${{ github.sha }}\`](https://github.com/${{ github.repository }}/commit/${{ github.sha }})\", \"inline\": true},
                {\"name\": \"Build\", \"value\": \"${{ needs.build.result }}\", \"inline\": true},
                {\"name\": \"Tests\", \"value\": \"${{ needs.test.result }}\", \"inline\": true},
                {\"name\": \"Deploy\", \"value\": \"${{ needs.deploy.result }}\", \"inline\": true}
              ],
              \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\"
            }]
          }" \
          "${{ secrets.DISCORD_WEBHOOK }}" || echo "Discord notification failed"
          
    - name: üì± Slack Notification  
      if: ${{ secrets.SLACK_WEBHOOK }}
      run: |
        STATUS_EMOJI="${{ steps.status.outputs.status == 'success' && 'üéâ' || '‚ùå' }}"
        curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"text\": \"$STATUS_EMOJI PlanetPlant Deployment ${{ steps.status.outputs.status == 'success' && 'Successful' || 'Failed' }}\",
            \"blocks\": [
              {
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*PlanetPlant Production Deployment*\n${{ steps.status.outputs.message }}\"
                }
              },
              {
                \"type\": \"section\",
                \"fields\": [
                  {\"type\": \"mrkdwn\", \"text\": \"*Version:*\n${{ needs.build.outputs.version }}\"},
                  {\"type\": \"mrkdwn\", \"text\": \"*Branch:*\n${{ github.ref_name }}\"},
                  {\"type\": \"mrkdwn\", \"text\": \"*Build:*\n${{ needs.build.result }}\"},
                  {\"type\": \"mrkdwn\", \"text\": \"*Tests:*\n${{ needs.test.result }}\"},
                  {\"type\": \"mrkdwn\", \"text\": \"*Deploy:*\n${{ needs.deploy.result }}\"}
                ]
              }
            ]
          }" \
          "${{ secrets.SLACK_WEBHOOK }}" || echo "Slack notification failed"
          
    - name: üìù Deployment Summary
      run: |
        echo "üìã Deployment Summary"
        echo "===================="
        echo "üè∑Ô∏è  Version: ${{ needs.build.outputs.version }}"
        echo "üåø Branch: ${{ github.ref_name }}"
        echo "üì¶ Build: ${{ needs.build.result }}"
        echo "üß™ Tests: ${{ needs.test.result }}"
        echo "üöÄ Deploy: ${{ needs.deploy.result }}"
        echo "üì± Status: ${{ steps.status.outputs.status }}"
        echo ""
        if [[ "${{ steps.status.outputs.status }}" == "success" ]]; then
          echo "üéâ PlanetPlant is now running the latest version on Raspberry Pi!"
          echo "üåê Access: http://${{ secrets.PI_HOST }}"
        else
          echo "‚ùå Deployment failed. Check logs and consider manual intervention."
        fi